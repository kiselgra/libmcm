/* 
 * Autogenerated by rtgen. Licenced under the terms of the GPL.
 */

#include "camera-matrices.h"

#include "matrix.h"
#include "vectors.h"

void make_gl_viewing_matrixd(matrix4x4d *out, const matrix4x4d *lookat)
{
	out->col_major[((0 * 4) + 0)] = lookat->col_major[((0 * 4) + 0)];
	out->col_major[((1 * 4) + 0)] = lookat->col_major[((0 * 4) + 1)];
	out->col_major[((2 * 4) + 0)] = lookat->col_major[((0 * 4) + 2)];
	out->col_major[((0 * 4) + 1)] = lookat->col_major[((1 * 4) + 0)];
	out->col_major[((1 * 4) + 1)] = lookat->col_major[((1 * 4) + 1)];
	out->col_major[((2 * 4) + 1)] = lookat->col_major[((1 * 4) + 2)];
	out->col_major[((0 * 4) + 2)] = -lookat->col_major[((2 * 4) + 0)];
	out->col_major[((1 * 4) + 2)] = -lookat->col_major[((2 * 4) + 1)];
	out->col_major[((2 * 4) + 2)] = -lookat->col_major[((2 * 4) + 2)];
	out->col_major[((0 * 4) + 3)] = 0;
	out->col_major[((1 * 4) + 3)] = 0;
	out->col_major[((2 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 3)] = 1;
	vec3d neg_pos;
	vec3d right;
	vec3d up;
	vec3d neg_dir;
	make_vec3d(&neg_pos, -lookat->col_major[((3 * 4) + 0)], -lookat->col_major[((3 * 4) + 1)], -lookat->col_major[((3 * 4) + 2)]);
	make_vec3d(&right, lookat->col_major[((0 * 4) + 0)], lookat->col_major[((0 * 4) + 1)], lookat->col_major[((0 * 4) + 2)]);
	make_vec3d(&up, lookat->col_major[((1 * 4) + 0)], lookat->col_major[((1 * 4) + 1)], lookat->col_major[((1 * 4) + 2)]);
	make_vec3d(&neg_dir, -lookat->col_major[((2 * 4) + 0)], -lookat->col_major[((2 * 4) + 1)], -lookat->col_major[((2 * 4) + 2)]);
	out->col_major[((3 * 4) + 0)] = dot_vec3d(&right, &neg_pos);
	out->col_major[((3 * 4) + 1)] = dot_vec3d(&up, &neg_pos);
	out->col_major[((3 * 4) + 2)] = dot_vec3d(&neg_dir, &neg_pos);

}

void make_gl_viewing_matrixf(matrix4x4f *out, const matrix4x4f *lookat)
{
	out->col_major[((0 * 4) + 0)] = lookat->col_major[((0 * 4) + 0)];
	out->col_major[((1 * 4) + 0)] = lookat->col_major[((0 * 4) + 1)];
	out->col_major[((2 * 4) + 0)] = lookat->col_major[((0 * 4) + 2)];
	out->col_major[((0 * 4) + 1)] = lookat->col_major[((1 * 4) + 0)];
	out->col_major[((1 * 4) + 1)] = lookat->col_major[((1 * 4) + 1)];
	out->col_major[((2 * 4) + 1)] = lookat->col_major[((1 * 4) + 2)];
	out->col_major[((0 * 4) + 2)] = -lookat->col_major[((2 * 4) + 0)];
	out->col_major[((1 * 4) + 2)] = -lookat->col_major[((2 * 4) + 1)];
	out->col_major[((2 * 4) + 2)] = -lookat->col_major[((2 * 4) + 2)];
	out->col_major[((0 * 4) + 3)] = 0;
	out->col_major[((1 * 4) + 3)] = 0;
	out->col_major[((2 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 3)] = 1;
	vec3f neg_pos;
	vec3f right;
	vec3f up;
	vec3f neg_dir;
	make_vec3f(&neg_pos, -lookat->col_major[((3 * 4) + 0)], -lookat->col_major[((3 * 4) + 1)], -lookat->col_major[((3 * 4) + 2)]);
	make_vec3f(&right, lookat->col_major[((0 * 4) + 0)], lookat->col_major[((0 * 4) + 1)], lookat->col_major[((0 * 4) + 2)]);
	make_vec3f(&up, lookat->col_major[((1 * 4) + 0)], lookat->col_major[((1 * 4) + 1)], lookat->col_major[((1 * 4) + 2)]);
	make_vec3f(&neg_dir, -lookat->col_major[((2 * 4) + 0)], -lookat->col_major[((2 * 4) + 1)], -lookat->col_major[((2 * 4) + 2)]);
	out->col_major[((3 * 4) + 0)] = dot_vec3f(&right, &neg_pos);
	out->col_major[((3 * 4) + 1)] = dot_vec3f(&up, &neg_pos);
	out->col_major[((3 * 4) + 2)] = dot_vec3f(&neg_dir, &neg_pos);

}

void make_projection_matrixd(matrix4x4d *out, double fovy_degree, double aspect, double near, double far)
{
	double f = (1 / tan((fovy_degree * (M_PI / 180))));
	double n_f = (near - far);
	make_unit_matrix4x4d(out);
	out->col_major[((0 * 4) + 0)] = (f / aspect);
	out->col_major[((1 * 4) + 1)] = f;
	out->col_major[((2 * 4) + 2)] = ((near + far) / n_f);
	out->col_major[((3 * 4) + 2)] = ((2 * (near * far)) / n_f);
	out->col_major[((2 * 4) + 3)] = -1;
	out->col_major[((3 * 4) + 3)] = 0;

}

void make_projection_matrixf(matrix4x4f *out, float fovy_degree, float aspect, float near, float far)
{
	float f = (1 / tan((fovy_degree * (M_PI / 180))));
	float n_f = (near - far);
	make_unit_matrix4x4f(out);
	out->col_major[((0 * 4) + 0)] = (f / aspect);
	out->col_major[((1 * 4) + 1)] = f;
	out->col_major[((2 * 4) + 2)] = ((near + far) / n_f);
	out->col_major[((3 * 4) + 2)] = ((2 * (near * far)) / n_f);
	out->col_major[((2 * 4) + 3)] = -1;
	out->col_major[((3 * 4) + 3)] = 0;

}

void make_lookat_matrixd(matrix4x4d *out, const vec3d *pos, const vec3d *dir, const vec3d *up)
{
	vec3d use_dir;
	vec3d right;
	vec3d use_up;
	copy_vec3d(&use_dir, dir);
	normalize_vec3d(&use_dir);
	cross_vec3d(&right, &use_dir, up);
	normalize_vec3d(&right);
	cross_vec3d(&use_up, &right, &use_dir);
	normalize_vec3d(&use_up);
	out->col_major[((0 * 4) + 0)] = right.x;
	out->col_major[((0 * 4) + 1)] = right.y;
	out->col_major[((0 * 4) + 2)] = right.z;
	out->col_major[((0 * 4) + 3)] = 0;
	out->col_major[((1 * 4) + 0)] = use_up.x;
	out->col_major[((1 * 4) + 1)] = use_up.y;
	out->col_major[((1 * 4) + 2)] = use_up.z;
	out->col_major[((1 * 4) + 3)] = 0;
	out->col_major[((2 * 4) + 0)] = use_dir.x;
	out->col_major[((2 * 4) + 1)] = use_dir.y;
	out->col_major[((2 * 4) + 2)] = use_dir.z;
	out->col_major[((2 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 0)] = pos->x;
	out->col_major[((3 * 4) + 1)] = pos->y;
	out->col_major[((3 * 4) + 2)] = pos->z;
	out->col_major[((3 * 4) + 3)] = 1;

}

void make_lookat_matrixf(matrix4x4f *out, const vec3f *pos, const vec3f *dir, const vec3f *up)
{
	vec3f use_dir;
	vec3f right;
	vec3f use_up;
	copy_vec3f(&use_dir, dir);
	normalize_vec3f(&use_dir);
	cross_vec3f(&right, &use_dir, up);
	normalize_vec3f(&right);
	cross_vec3f(&use_up, &right, &use_dir);
	normalize_vec3f(&use_up);
	out->col_major[((0 * 4) + 0)] = right.x;
	out->col_major[((0 * 4) + 1)] = right.y;
	out->col_major[((0 * 4) + 2)] = right.z;
	out->col_major[((0 * 4) + 3)] = 0;
	out->col_major[((1 * 4) + 0)] = use_up.x;
	out->col_major[((1 * 4) + 1)] = use_up.y;
	out->col_major[((1 * 4) + 2)] = use_up.z;
	out->col_major[((1 * 4) + 3)] = 0;
	out->col_major[((2 * 4) + 0)] = use_dir.x;
	out->col_major[((2 * 4) + 1)] = use_dir.y;
	out->col_major[((2 * 4) + 2)] = use_dir.z;
	out->col_major[((2 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 0)] = pos->x;
	out->col_major[((3 * 4) + 1)] = pos->y;
	out->col_major[((3 * 4) + 2)] = pos->z;
	out->col_major[((3 * 4) + 3)] = 1;

}

void make_ortographic_matirxd(matrix4x4d *out, double right, double left, double top, double bottom, double near, double far)
{
	double r_l = (right - left);
	double t_b = (top - bottom);
	double f_n = (far - near);
	make_unit_matrix4x4d(out);
	out->col_major[((0 * 4) + 0)] = (2 / r_l);
	out->col_major[((1 * 4) + 1)] = (2 / t_b);
	out->col_major[((2 * 4) + 2)] = (2 / f_n);
	out->col_major[((3 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 0)] = -((right + left) / r_l);
	out->col_major[((3 * 4) + 1)] = -((top + bottom) / t_b);
	out->col_major[((3 * 4) + 2)] = -((far + near) / f_n);

}

void make_ortographic_matirxf(matrix4x4f *out, float right, float left, float top, float bottom, float near, float far)
{
	float r_l = (right - left);
	float t_b = (top - bottom);
	float f_n = (far - near);
	make_unit_matrix4x4f(out);
	out->col_major[((0 * 4) + 0)] = (2 / r_l);
	out->col_major[((1 * 4) + 1)] = (2 / t_b);
	out->col_major[((2 * 4) + 2)] = (2 / f_n);
	out->col_major[((3 * 4) + 3)] = 0;
	out->col_major[((3 * 4) + 0)] = -((right + left) / r_l);
	out->col_major[((3 * 4) + 1)] = -((top + bottom) / t_b);
	out->col_major[((3 * 4) + 2)] = -((far + near) / f_n);

}

